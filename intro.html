<!--
Le truc important a pas oublier !!
-->
<style>

    @import url(//cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.5/leaflet.css);

    #map {
        width: 960px;
        height: 500px;
    }

    svg {
        position: relative;
    }
</style>

<script src="https://d3js.org/d3.v4.min.js" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.5/leaflet.js"></script>
<script src="js/lib/geotiff.js"></script>

<html>
<p id="map">
</p>

<a href="https://global.nature.org/content/beyond-the-source?src=r.global.beyondthesource">More about source water protection</a>

</html>


<script>


    var colorsRange = [
        ['#FF8888', '#FF8888'],
        ['#77FF77', '#77FF77'],
        ['#7777FF', '#7777ff']];

    var bitmaps  = [];

    // j'ai change les tchiffres a cause du binz de la projection
    /*
     Generic  Canvas Layer for leaflet 0.7 and 1.0-rc,
     copyright Stanislav Sumbera,  2016 , sumbera.com , license MIT
     originally created and motivated by L.CanvasOverlay  available here: https://gist.github.com/Sumbera/11114288

     */

    // -- L.DomUtil.setTransform from leaflet 1.0.0 to work on 0.0.7
    //------------------------------------------------------------------------------
    L.DomUtil.setTransform = L.DomUtil.setTransform || function (el, offset, scale) {
            var pos = offset || new L.Point(0, 0);

            el.style[L.DomUtil.TRANSFORM] =
                (L.Browser.ie3d ?
                    'translate(' + pos.x + 'px,' + pos.y + 'px)' :
                    'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
                (scale ? ' scale(' + scale + ')' : '');
        };

    // -- support for both  0.0.7 and 1.0.0 rc2 leaflet
    L.CanvasLayer = (L.Layer ? L.Layer : L.Class).extend({
        // -- initialized is called on prototype
        initialize: function (options) {
            this._map    = null;
            this._canvas = null;
            this._frame  = null;
            this._delegate = null;
            L.setOptions(this, options);
        },

        delegate :function(del){
            this._delegate = del;
            return this;
        },

        needRedraw: function () {
            if (!this._frame) {
                this._frame = L.Util.requestAnimFrame(this.drawLayer, this);
            }
            return this;
        },

        //-------------------------------------------------------------
        _onLayerDidResize: function (resizeEvent) {
            this._canvas.width = resizeEvent.newSize.x;
            this._canvas.height = resizeEvent.newSize.y;
        },
        //-------------------------------------------------------------
        _onLayerDidMove: function () {
            var topLeft = this._map.containerPointToLayerPoint([0, 0]);
            L.DomUtil.setPosition(this._canvas, topLeft);
            this.drawLayer();
        },
        //-------------------------------------------------------------
        getEvents: function () {
            var events = {
                resize: this._onLayerDidResize,
                moveend: this._onLayerDidMove
            };
            if (this._map.options.zoomAnimation && L.Browser.any3d) {
                events.zoomanim =  this._animateZoom;
            }

            return events;
        },
        //-------------------------------------------------------------
        onAdd: function (map) {
            this._map = map;
            this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');
            this.tiles = {};

            var size = this._map.getSize();
            this._canvas.width = size.x;
            this._canvas.height = size.y;

            var animated = this._map.options.zoomAnimation && L.Browser.any3d;
            L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));


            map._panes.overlayPane.appendChild(this._canvas);

            map.on(this.getEvents(),this);

            var del = this._delegate || this;
            del.onLayerDidMount && del.onLayerDidMount(); // -- callback
            this.needRedraw();
        },

        //-------------------------------------------------------------
        onRemove: function (map) {
            var del = this._delegate || this;
            del.onLayerWillUnmount && del.onLayerWillUnmount(); // -- callback


            map.getPanes().overlayPane.removeChild(this._canvas);

            map.off(this.getEvents(),this);

            this._canvas = null;

        },

        //------------------------------------------------------------
        addTo: function (map) {
            map.addLayer(this);
            return this;
        },
        // --------------------------------------------------------------------------------
        LatLonToMercator: function (latlon) {
            return {
                x: latlon.lng * 6378137 * Math.PI / 180,
                y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137   //
            };
        },

        //------------------------------------------------------------------------------
        drawLayer: function () {
            // -- todo make the viewInfo properties  flat objects.
            var size   = this._map.getSize();
            var bounds = this._map.getBounds();
            var zoom   = this._map.getZoom();

            var center = this._map.getCenter();
            var corner = this._map.containerPointToLatLng(this._map.getSize());

            var del = this._delegate || this;
            del.onDrawLayer && del.onDrawLayer( {
                layer : this,
                canvas: this._canvas,
                bounds: bounds,
                size: size,
                zoom: zoom,
                center : center,
                corner : corner
            });
            this._frame = null;
        },
        // -- L.DomUtil.setTransform from leaflet 1.0.0 to work on 0.0.7
        //------------------------------------------------------------------------------
        _setTransform: function (el, offset, scale) {
            var pos = offset || new L.Point(0, 0);

            el.style[L.DomUtil.TRANSFORM] =
                (L.Browser.ie3d ?
                    'translate(' + pos.x + 'px,' + pos.y + 'px)' :
                    'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
                (scale ? ' scale(' + scale + ')' : '');
        },

        //------------------------------------------------------------------------------
        _animateZoom: function (e) {

            var scale = this._map.getZoomScale(e.zoom);
            console.log('in animate zoom', scale);
            // -- different calc of offset in leaflet 1.0.0 and 0.0.7 thanks for 1.0.0-rc2 calc @jduggan1
            var offset = L.Layer ? this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center) :
                this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

            L.DomUtil.setTransform(this._canvas, offset, scale);


        }
    });

    L.canvasLayer = function () {
        return new L.CanvasLayer();
    };

</script>


<script>

    var imageData;
    var imgBitmap;
    var sx = 950 / 1936;
    var sy = 500 / 599;

    var scaleAccumuled = 1;
    var lastScale;

    // see http://bl.ocks.org/mbostock/6301817 for a good example on how to constraint the map


    // open the map, setup center and zoom level
    var map = new L.Map("map", {center: [37.8, -96.9], zoom: 4})
        .addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));

    var myCustomCanvasDraw = function(){
        this.onLayerDidMount = function (){
            // -- prepare custom drawing
            console.log('ca sert a kekchose je sais plus ?????');
        };
        this.onLayerWillUnmount  = function(){
            // -- custom cleanup
        };
        this.setData = function (data){
            // -- custom data set
            console.log('ca sert a kekchose je sais plus2 ?????');
            this.needRedraw(); // -- call to drawLayer
        };

        // this will be called automatically
        this.onDrawLayer = function (canvasOverlay, params){
            //console.log('ca sert a kekchose je sais plus le retour 3 ?????');
            var ctx = canvasOverlay.canvas.getContext('2d');
            // je donne un mauvais example aux generations futures :)
            ctx.clearRect(0, 0, 5000, 5000);
            // -- custom  draw
            /*var d = circles[0].coordinates;
             // THIS MAKES THE MAGIC, SO WHY IT IS COMMENTED ?????
             var point = map.latLngToContainerPoint(new L.LatLng(d[0], d[1]));
             // OR
             ctx.beginPath();
             ctx.arc(point.x, point.y, 40, 0, 2 * Math.PI);
             ctx.stroke();
             ctx.globalAlpha = 0.0;
             ctx.fillStyle = '#AAF255';
             ctx.fill();*/
            // this was a circle on new york ??
            var newExt, image, colorScale;
            // we make this crap here but it SHOULD BE PULLED OUTSIDE
            if (!imgBitmap) {

                var shed1Request = d3.request("./data/intro_all_watersheds/lulc_4_M.tif").responseType('arraybuffer');
                var shed2Request = d3.request("./data/intro_all_watersheds/lulc_4_S.tif").responseType('arraybuffer');
                var shed3Request = d3.request("./data/intro_all_watersheds/lulc_4_TC.tif").responseType('arraybuffer');

                d3.queue()
                    .defer(shed1Request.get)
                    .defer(shed2Request.get)
                    .defer(shed3Request.get)
                    .awaitAll(function  (error, data) {
                        console.log('loaded');
                        data.forEach(function(data, index) {
                            var parser = GeoTIFF.parse(data.response);
                            image = parser.getImage();
                            rasters = image.readRasters();
                            // there is some arbitrary value fow 'no data', that messes all my calculations
                            ext = d3.extent(rasters[0]);
                            newExt = d3.extent(rasters[0].filter(function (r) {
                                return r != ext[0];
                            }));
                            baseRaster = rasters[0];
                            render(baseRaster, ext, newExt, image, boundsArray[index], index);
                        });

                    });

                // Try to reduce the number of args
                function render(baseRaster, ext, newExt, image, bound, index) {

                    imageData = ctx.createImageData(image.getWidth(), image.getHeight());
                    var data = imageData.data;
                    var o = 0;
                    var color = d3.color(colorsRange[index][0]);
                    // WE DO NOT USE GLOBAL ALPHA THERE
                    baseRaster.forEach(function (r) {
                        if (r === ext[0]) {
                            data[o] = 255;
                            data[o + 1] = 255;
                            data[o + 2] = 255;
                            data[o + 3] = 0;
                            o += 4;
                            return;
                        }
                        data[o] = color.r;
                        data[o + 1] = color.g;
                        data[o + 2] = color.b;
                        data[o + 3] = 200;
                        o += 4;
                    });


                    var containerSw = map.latLngToContainerPoint(bound.southWest);
                    var containerNe = map.latLngToContainerPoint(bound.northEast);
                    createImageBitmap(imageData).then(function (response) {
                        imgBitmap = response;
                        // commented part is not used anymore
                        //ctx.save();
                        //ctx.scale(sx, sy);
                        bitmaps[index] = response;
                        ctx.drawImage(imgBitmap, containerSw.x, containerSw.y, containerNe.x - containerSw.x, containerNe.y - containerSw.y);
                        //ctx.restore();
                    });
                }
            } else {

                bitmaps.forEach(function(bitmap, index) {
                    var bound = boundsArray[index];
                    var containerSw = map.latLngToContainerPoint(bound.southWest);
                    var containerNe = map.latLngToContainerPoint(bound.northEast);
                    ctx.drawImage(bitmap, containerSw.x, containerSw.y,
                        containerNe.x - containerSw.x, containerNe.y - containerSw.y);
                });
            }
        }
    };

    myCustomCanvasDraw.prototype = new L.CanvasLayer(); // -- setup prototype
    var myLayer = new myCustomCanvasDraw();
    myLayer.addTo(map);
    map.on("viewreset", reset);
    reset();
    // Reposition the SVG to cover the features. Mais do not care parce qu'on
    // a pas de svg et tout de facon c'etait tout moisi
    function reset() { }

    // communique par les services secrets de Charlie.. mais pourquoi mes calculs sont tout foireux ?
    // TODO use pro4j
    // NORD : 37.00270,-0.52535
    // WEST 36.74436,-0.56370
    // SUD 36.85814,-0.60707
    // EST 37.00559,-0.52753
    var boundsArray = [
        {
            southWest: L.latLng(-0.63466 , 36.70657),
            northEast: L.latLng(-0.82007, 37.26312 )
        }, {
            southWest: L.latLng(-0.63174 , 36.50179),
            northEast: L.latLng(-0.16380, 37.31485 )
        }, {
            southWest: L.latLng(-1.04606 , 37.07796),
            northEast: L.latLng(-0.62339, 36.57871)
        }
    ];


        var bounds = L.latLngBounds(boundsArray[1].southWest, boundsArray[2].southWest);
    map.fitBounds(bounds);
    //s : 37.31485 -0.16380 36.60179 -0.63174
    //tc : 36.57871 -0.62339 37.07796 -1.04606
    //m: 36.70657 -0.63466 37.26312 -0.82007

</script>

